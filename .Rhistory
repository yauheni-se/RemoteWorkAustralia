mean(boot::cv.glm(data_set, model_sel2, cost = function(y, yhat) {Metrics::mse(actual = y, predicted = yhat)}, K=10)$delta)
model_glm_best <- model_sel2
# TREE-BASED MODELS ----
model_tree <- rpart(log(ClaimAmount)/ClaimNb ~ VehUsage+BonusMalus+log(Exposure)+DrivAge+RiskAreaGroup, data = data_set, method = "anova")
summary(model_tree)
rpart.rules(model_tree)
rpart.plot(model_tree,tweak=1.5)
printcp(model_tree)
plotcp(model_tree)
# PRESETS ----
library(CASdatasets)
library(tidyverse)
library(MASS)
library(lsr)
library(xts)
library(zoo)
library(sp)
library(rpart)
library(rpart.plot)
library(Hmisc)
library(caret)
rm(list = ls())
set.seed(42)
# DATA PREPARATION ----
data(freMPL9)
df <- freMPL9
rm(freMPL9)
str(df)
df_sel <- df %>%
as_tibble() %>%
dplyr::filter(DrivAge>=18, Exposure>0, ClaimAmount>0) %>%
mutate(ClaimNb = ClaimNbResp+ClaimNbNonResp+ClaimNbParking+ClaimNbFireTheft+ClaimNbWindscreen+OutUseNb) %>%
dplyr::filter(!(ClaimAmount !=0 & ClaimNb == 0)) %>%    # filtrujemy zle wpisy z liczbą szkód = 0 ale wartością szkód != 0
dplyr::select(ClaimAmount, ClaimNb, Exposure, Gender, DrivAge, BonusMalus, VehUsage, RiskArea) %>%    # wybieramy interesujące zmienne
mutate(
RiskArea = as.factor(RiskArea),
ClaimAmountLog = log(ClaimAmount)#,
#ClaimAmountSingle = ClaimAmount/ClaimNb,
#ClaimAmountSingleLog = log(ClaimAmountSingle)
)
rm(df)
# EDA ----
# * Functions ----
make_point <- function(variable, df=df_sel, variable_y = "ClaimAmount") {
df %>%
ggplot(aes_string(variable, variable_y)) +
geom_point(color = "#29d9d9") +
theme(
panel.background = element_rect(fill = "#e4dcdc"),
plot.background = element_rect(fill = "#e4dcdc"),
panel.grid.major.y = element_line(color = "#cacaca"),
panel.grid.minor = element_blank(),
panel.grid.major.x = element_line(color = "#cacaca")
)
}
make_box <- function(variable, df=df_sel, variable_y = "ClaimAmount") {
df %>%
ggplot(aes_string(variable, variable_y)) +
geom_boxplot(fill = "#29d9d9") +
theme(
panel.background = element_rect(fill = "#e4dcdc"),
plot.background = element_rect(fill = "#e4dcdc"),
panel.grid.major.y = element_line(color = "#cacaca"),
panel.grid.minor = element_blank(),
panel.grid.major.x = element_line(color = "#cacaca")
)
}
make_density <- function(variable, df, plot_type = "density") {
df %>%
ggplot(aes_string(x = variable)) +
do.call(paste0("geom_", plot_type), list(fill = "#29d9d9", alpha = 0.6, color = "#131313")) +
labs(y = "") +
theme(
axis.text.y = element_blank(),
axis.ticks.y = element_blank(),
panel.background = element_rect(fill = "#e4dcdc"),
plot.background = element_rect(fill = "#e4dcdc"),
panel.grid.major.y = element_blank(),
panel.grid.minor = element_blank(),
panel.grid.major.x = element_line(color = "#cacaca")
)
}
make_qq <- function(variable, df) {
ggplot(df_sel, aes_string(sample = variable)) +
stat_qq(color = "#29d9d9") +
stat_qq_line(size = 1.2)+
labs(y = "", x = variable) +
theme(
panel.background = element_rect(fill = "#e4dcdc"),
plot.background = element_rect(fill = "#e4dcdc"),
panel.grid.major.y = element_line(color = "#cacaca"),
panel.grid.minor = element_blank(),
panel.grid.major.x = element_line(color = "#cacaca")
)
}
make_density_cat <- function(variable, df) {
df %>%
ggplot(aes_string(variable)) +
geom_bar(color = "#131313", fill = "#29d9d9", alpha = 0.6) +
geom_text(stat='count', aes(label=..count..), vjust=-1) +
labs(y = "") +
theme(
panel.background = element_rect(fill = "#e4dcdc"),
plot.background = element_rect(fill = "#e4dcdc"),
panel.grid.major = element_line(color = "#cacaca"),
panel.grid.minor = element_blank()
)
}
# * Explainable variables ----
variables_main <- c("ClaimAmount", "ClaimAmountLog")
lapply(variables_main, make_density, df_sel)
lapply(variables_main, make_density, df_sel, "histogram")
lapply(variables_main, make_qq, df_sel)
lapply("ClaimNb", make_density, df_sel)
lapply("ClaimNb", make_density, df_sel, "histogram")
df_sel$ClaimNb %>% table()
# * Numeric variables ----
vars_numeric <- c("DrivAge", "Exposure", "BonusMalus")
lapply(vars_numeric, make_density, df_sel)
df_sel <- df_sel %>%
mutate(BonusMalusLog = log(BonusMalus))
lapply("BonusMalusLog", make_point, df_sel, "ClaimAmountLog")
lapply(c("DrivAge", "Exposure"), make_point, df_sel, "ClaimAmountLog")
df_sel %>%
dplyr::select(ClaimAmountLog, BonusMalusLog, DrivAge, Exposure) %>%
cor() %>%
as_tibble(rownames = "variable") %>%
mutate_if(is.numeric, round, 2)
# * Categorical Variables ----
vars_categorical <- c("Gender", "RiskArea", "VehUsage")
lapply(vars_categorical, make_density_cat, df_sel)
lapply(vars_categorical, make_box, df_sel, "ClaimAmountLog")
df_sel <- df_sel %>%
mutate(
RiskAreaGroup = ifelse(RiskArea %in% c(1, 2, 3), "1-3", ifelse(RiskArea %in% c(11, 12, 13), "11+", as.character(RiskArea))),
RiskAreaGroup = as.factor(RiskAreaGroup),
VehUsageGroup = ifelse(as.character(VehUsage) == "Professional run", "Professional", as.character(VehUsage)),
VehUsageGroup = as.factor(VehUsageGroup),
.keep = "unused"
) %>%
dplyr::select(-BonusMalus) %>%
rename(BonusMalus = BonusMalusLog, VehUsage = VehUsageGroup)
# GLM MODEL ----
data_set <- df_sel
rm(df_sel)
data_set
# Model
model_gamma <- glm(ClaimAmount/ClaimNb ~ Exposure+Gender+DrivAge+BonusMalus+RiskAreaGroup+VehUsage, family = Gamma(link = "log"), weights = ClaimNb, data_set)
summary(model_gamma)
exp(-0.689114)*100
# Prediction
prediction_var <- predict(model_gamma, newdata = data_set[1:2, ])    # predicted
real_var <- data_set[1:2, ] %>% mutate(tmp = log(ClaimAmount)/ClaimNb) %>% pull(tmp)    # real
round(((prediction_var-real_var))/real_var, 4)*100
# FEATURE SELECTION ----
model_full <- glm(ClaimAmount/ClaimNb ~ Exposure+Gender+DrivAge+BonusMalus+RiskAreaGroup+VehUsage, family = Gamma(link = "log"), weights = ClaimNb, data_set)
model_sel <- stepAIC(model_full)
summary(model_sel)
drop1(model_full, test = "F")
model_gamma_reduced <- glm(ClaimAmount/ClaimNb ~ Exposure+Gender+DrivAge+RiskAreaGroup+VehUsage, family = Gamma(link = "log"), weights = ClaimNb, data_set)
drop1(model_gamma_reduced, test = "F")
model_gamma_reduced <- glm(ClaimAmount/ClaimNb ~ Exposure+Gender+RiskAreaGroup+VehUsage, family = Gamma(link = "log"), weights = ClaimNb, data_set)
drop1(model_gamma_reduced, test = "F")
# JAKOSC DOPASOWANIA MODELU ----
model_gamma_reduced <- glm(ClaimAmount/ClaimNb ~ Exposure+Gender+DrivAge+BonusMalus+VehUsage, family = Gamma(link = "log"), weights = ClaimNb, data_set)
summary(model_gamma_reduced)
model_prediction_reduced <- predict(model_gamma_reduced, type = "response")
# wykres reszt
tibble(
res = residuals(model_gamma_reduced,type="deviance"),
pred = predict(model_gamma_reduced,type="link")
) %>%
ggplot() +
geom_point(aes(pred, res), color = "#29d9d9") +
labs(x = "Linear predictor", y = "Residuals") +
theme(
panel.background = element_rect(fill = "#e4dcdc"),
plot.background = element_rect(fill = "#e4dcdc"),
panel.grid.major.y = element_line(color = "#cacaca"),
panel.grid.minor = element_blank(),
panel.grid.major.x = element_line(color = "#cacaca")
) +
geom_abline(slope = 0, intercept = 0)
tibble(
obs = data_set$ClaimAmount/data_set$ClaimNb,
mu_pred = model_prediction_reduced
) %>%
ggplot() +
geom_point(aes(mu_pred, obs), color = "#29d9d9") +
labs(x = "Predictions mu", y = "Observations") +
theme(
panel.background = element_rect(fill = "#e4dcdc"),
plot.background = element_rect(fill = "#e4dcdc"),
panel.grid.major.y = element_line(color = "#cacaca"),
panel.grid.minor = element_blank(),
panel.grid.major.x = element_line(color = "#cacaca")
) +
geom_abline(slope = 1, intercept = 0)
#QQ plot
beta <- data_set$ClaimNb/model_prediction_reduced/summary(model_gamma_reduced)$dispersion
alpha <- data_set$ClaimNb/summary(model_gamma_reduced)$dispersion
quantile_residual <- pgamma(data_set$ClaimAmount/data_set$ClaimNb, shape = alpha, rate = beta)
quantile_residual <- qnorm(quantile_residual, 0, 1)
par(bg = "#e4dcdc")
qqnorm(quantile_residual, col = "#29d9d9", pch = 20, xlim = c(-4, 4), ylim = c(-4, 4), bty = "n")
abline(0, 1, col = "black")
# SECOND GLM MODEL ----
summary(model_sel)
model_full2 <- glm(log(ClaimAmount)/ClaimNb~VehUsage+BonusMalus+log(Exposure)+DrivAge+RiskAreaGroup+Gender, family = inverse.gaussian(link = "1/mu^2"), data_set)
model_sel2 <- stepAIC(model_full2)
summary(model_sel2)
# COMPARE GLMS WITH CV ----
mean(boot::cv.glm(data_set, model_gamma_reduced, cost = function(y, yhat) {Metrics::mse(actual = y, predicted = yhat)}, K=10)$delta)
mean(boot::cv.glm(data_set, model_sel2, cost = function(y, yhat) {Metrics::mse(actual = y, predicted = yhat)}, K=10)$delta)
model_glm_best <- model_sel2
model_sel2 %>% summary()
model_tree <- rpart(log(ClaimAmount)/ClaimNb ~ VehUsage+BonusMalus+DrivAge, data = data_set, method = "anova")
summary(model_tree)
rpart.rules(model_tree)
rpart.plot(model_tree,tweak=1.5)
printcp(model_tree)
plotcp(model_tree)
predict(model_tree, type = "response")
predict(model_tree, type = "vector")
predict(model_tree)
residuals(model_tree,type="deviance")
predict(model_tree,type="link")
tibble(
res = residuals(model_tree, type = "deviance"),
pred = predict(model_tree, type = "vector")
)
tibble(
res = residuals(model_tree, type = "deviance"),
pred = predict(model_tree, type = "vector")
) %>%
ggplot() +
geom_point(aes(pred, res), color = "#29d9d9") +
labs(x = "Linear predictor", y = "Residuals") +
theme(
panel.background = element_rect(fill = "#e4dcdc"),
plot.background = element_rect(fill = "#e4dcdc"),
panel.grid.major.y = element_line(color = "#cacaca"),
panel.grid.minor = element_blank(),
panel.grid.major.x = element_line(color = "#cacaca")
) +
geom_abline(slope = 0, intercept = 0)
residuals(model_tree, type = "deviance")
residuals(model_tree)
tibble(
res = residuals(model_tree),
pred = predict(model_tree, type = "vector")
) %>%
ggplot() +
geom_point(aes(pred, res), color = "#29d9d9") +
labs(x = "Linear predictor", y = "Residuals") +
theme(
panel.background = element_rect(fill = "#e4dcdc"),
plot.background = element_rect(fill = "#e4dcdc"),
panel.grid.major.y = element_line(color = "#cacaca"),
panel.grid.minor = element_blank(),
panel.grid.major.x = element_line(color = "#cacaca")
)
# wykres reszt
plot(predict(model_tree),residuals(model_tree))
predict(model_tree)
predict(model_tree) %>% unique()
model_tree <- rpart(log(ClaimAmount)/ClaimNb ~ VehUsage+BonusMalus+DrivAge, data = data_set)
summary(model_tree)
rpart.rules(model_tree)
rpart.plot(model_tree,tweak=1.5)
printcp(model_tree)
plotcp(model_tree)
model_prediction_tree <- predict(model_tree)
model_prediction_tree
model_prediction_tree %>% unique()
plot(predict(model_tree),residuals(model_tree))
tibble(
res = residuals(model_tree),
pred = predict(model_tree, type = "vector")
) %>%
ggplot() +
geom_point(aes(pred, res), color = "#29d9d9") +
labs(x = "Linear predictor", y = "Residuals") +
theme(
panel.background = element_rect(fill = "#e4dcdc"),
plot.background = element_rect(fill = "#e4dcdc"),
panel.grid.major.y = element_line(color = "#cacaca"),
panel.grid.minor = element_blank(),
panel.grid.major.x = element_line(color = "#cacaca")
) +
geom_abline(slope = 0, intercept = 0)
mse_metric <- function(data, lev = NULL, model = NULL) {
mse_val <- Metrics::mse(actual = data$obs, predicted = data$pred)
c(mse = mse_val)
}
validated_glm <- train(log(ClaimAmount)/ClaimNb ~ VehUsage+BonusMalus+log(Exposure)+DrivAge+RiskAreaGroup,
data = data_set,
method = "glm",
family = inverse.gaussian(link = "1/mu^2"),
metric = "mse",
trControl= trainControl(method = "cv", number = 10, summaryFunction = mse_metric)
)
validated_tree <- train(log(ClaimAmount)/ClaimNb ~ VehUsage+BonusMalus+log(Exposure)+DrivAge+RiskAreaGroup,
data = data_set,
method = "rpart",
metric = "mse",
trControl= trainControl(method = "cv", number = 10, summaryFunction = mse_metric)
)
min(validated_tree$results$mse)
min(validated_glm$results$mse)
tibble(
tree = validated_tree$resample %>% arrange(Resample) %>% pull(mse),
glm = validated_glm$resample %>% arrange(Resample) %>% pull(mse),
) %>%
mutate(index = row_number()) %>%
pivot_longer(cols = c(tree, glm)) %>%
rename(model = name) %>%
ggplot(aes(index, value, color = model)) +
geom_point(color = "black", alpha = 0.4, size = 2) +
geom_line(size = 2) +
labs(y = "mse value", x = "CV fold index") +
theme(
panel.background = element_rect(fill = "#e4dcdc"),
plot.background = element_rect(fill = "#e4dcdc"),
legend.background = element_rect(fill = "#e4dcdc"),
panel.grid.major.y = element_line(color = "#cacaca"),
panel.grid.minor = element_blank(),
panel.grid.major.x = element_line(color = "#cacaca")
)
tibble(
tree = min(validated_tree$results$mse),
glm = min(validated_glm$results$mse)
)
tibble(
`MSE - tree` = min(validated_tree$results$mse),
`MSE - glm` = min(validated_glm$results$mse)
)
tibble(
`MSE - tree` = validated_tree$resample %>% arrange(Resample) %>% pull(mse) %>% mean(),
`MSE - glm` = min(validated_glm$results$mse)
)
tibble(
`MSE - tree` = validated_tree$resample %>% arrange(Resample) %>% pull(mse) %>% mean(),
`MSE - glm` = validated_glm$resample %>% arrange(Resample) %>% pull(mse) %>% mean()
)
matrix(0, 4, 4)
grid <- matrix(0, 4, 4)
for (i in length(grid)):
print(i)
for (i in length(grid)) {
print(i)
}
for (i in 1:length(grid)) {
print(i)
}
for (i in 1:length(grid)) {
for (j in 1:length(grid)) {
print(i, j)
}
}
print(paste(i, j))
for (i in 1:length(grid)) {
for (j in 1:length(grid)) {
print(paste(i, j))
}
}
matrix(0, 4, 4)
grid
values <- c(1, 2, 3, 4)
# use expand.grid to generate all possible combinations of length 16
combinations <- expand.grid(replicate(16, values, simplify = FALSE))
# view the first 10 combinations
head(combinations, n = 10)
# create a vector of values from 1 to 4
values <- c(1, 2, 3, 4)
# use nested loops to generate all possible combinations
for (i in values) {
for (j in values) {
for (k in values) {
for (l in values) {
for (m in values) {
for (n in values) {
for (o in values) {
for (p in values) {
for (q in values) {
for (r in values) {
for (s in values) {
for (t in values) {
for (u in values) {
for (v in values) {
for (w in values) {
for (x in values) {
combination <- c(i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x)
print(combination)
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
source("~/.active-rstudio-document", echo=TRUE)
print(1)
reticulate::repl_python()
x = 1
x = 1
print(x)
x - 2
x ** 3
3 ** 3
setwd("C:/Projects/RemoteWorkSurvey")
df <- haven::read_dta("ytyt.dta")
df
df %>% mutate(
actual = y,
pred = ifelse(newvar==1, 1, ifelse(newvar2==1, 2, 3)),
.keep = "none"
)
library(tidyverse)
df <- haven::read_dta("ytyt.dta")
df
df %>% mutate(
actual = y,
pred = ifelse(newvar==1, 1, ifelse(newvar2==1, 2, 3)),
.keep = "none"
)
df %>% mutate(
actual = as.numeric(y),
pred = ifelse(newvar==1, 1, ifelse(newvar2==1, 2, 3)),
.keep = "none"
)
tmp <- df %>%
mutate(
actual = as.numeric(y),
pred = ifelse(newvar==1, 1, ifelse(newvar2==1, 2, 3)),
.keep = "none"
)
caret::confusionMatrix(tmp)
?caret::confusionMatrix
caret::confusionMatrix(tmp$actual, tmp$pred)
table(tmp$actual, tmp$pred)
table(tmp$pred, tmp$actual)
caret::confusionMatrix(tmp$pred, tmp$actual)
caret::confusionMatrix(tmp$pred %>% as.factor(), tmp$actual %>% as.factor())
caret::confusionMatrix(tmp$actual %>% as.factor(), tmp$pred %>% as.factor())
caret::confusionMatrix(tmp$pred %>% as.factor(), tmp$actual %>% as.factor())
caret::confusionMatrix(tmp$pred %>% as.factor(), tmp$actual %>% as.factor())
library(plotROC)
pROC::roc(tmp$pred, tmp$actual)
pROC::multiclass.roc(mp$pred, tmp$actual)
pROC::multiclass.roc(tmp$pred, tmp$actual)
pROC::roc(tmp$pred, tmp$actual)
pROC::multiclass.roc(tmp$pred, tmp$actual)
library(pROC)
roc.multi
roc.multi <- pROC::multiclass.roc(tmp$pred, tmp$actual)
roc.multi[['rocs']]
rs <- roc.multi[['rocs']]
plot.roc(rs[[1]])
sapply(2:length(rs),function(i) lines.roc(rs[[i]],col=i))
plot.roc(rs[[1]])
plot.roc(rs[[2]])
plot.roc(rs[[3]])
roc.multi[['rocs']]
roc.multi
roc.multi %>% summary(
)
roc.multi$rocs[[1]]
roc.multi <- pROC::multiclass.roc(tmp$pred, tmp$actual, auc=TRUE)
setwd("C:/Projects/RemoteWorkSurvey")
library(tidyverse)
library(pROC)
df <- haven::read_dta("ytyt.dta")
df
tmp <- df %>%
mutate(
actual = as.numeric(y),
pred = ifelse(newvar==1, 1, ifelse(newvar2==1, 2, 3)),
.keep = "none"
)
tmp
table(tmp$actual, tmp$pred)
caret::confusionMatrix(tmp$pred %>% as.factor(), tmp$actual %>% as.factor())
roc.multi <- pROC::multiclass.roc(tmp$pred, tmp$actual)
rs <- roc.multi[['rocs']]
sapply(2:length(rs),function(i) lines.roc(rs[[i]],col=i))
roc.multi <- pROC::multiclass.roc(tmp$pred, tmp$actual)
rs <- roc.multi[['rocs']]
plot.roc(rs[[1]])
sapply(2:length(rs),function(i) lines.roc(rs[[i]],col=i))
pROC::roc(tmp$pred, tmp$actual)
pROC::roc(tmp$pred, tmp$actual, levels = 1:3)
pROC::roc(tmp$pred, tmp$actual, levels = 1:2)
pROC::roc(tmp$pred, tmp$actual, levels = 2:3)
pROC::roc(tmp$pred, tmp$actual, levels = 1:3)
pROC::roc(tmp$pred, tmp$actual, levels = c(1, 3))
pROC::roc(tmp$pred, tmp$actual, levels = c(1, 2))
pROC::roc(tmp$pred, tmp$actual, levels = c(1, 2))$auc
pROC::roc(tmp$pred, tmp$actual, levels = c(1, 2))$auc
pROC::roc(tmp$pred, tmp$actual, levels = c(2, 3))$auc
pROC::roc(tmp$pred, tmp$actual, levels = c(1, 3))$auc
roc.multi <- pROC::multiclass.roc(tmp$pred, tmp$actual)
roc.multi
